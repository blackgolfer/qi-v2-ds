@import "table.css"

# The Producer Actor

## Definition

We can not model the producer as a Mealy machine due to the non-deterministic nature, we need state be able to emit events. This leads to the actor model, which is more suitable for the producer.

Unlike Mealy machines, which are inherently deterministic and reactive—responding strictly to external inputs—the Producer Actor requires the ability to **proactively generate events** based on internal state transitions and actions. This necessitates a model that supports **asynchronous communication**, **state encapsulation**, and **event-driven behavior**, all of which are core characteristics of the Actor Model.

Formally, the producer actor is a sextuple state machine \( M = \left<Q, \Sigma, \delta, \lambda, q_0, F\right> \), where:

- **\( Q \)**: The state space.
- **\( \Sigma \)**: The input space.
- **\( \delta \)**: The transition function, \( \delta: Q \times \Sigma \rightarrow Q \).
- **\( \lambda \)**: The action function, \( \lambda: Q \times \Sigma \rightarrow \Sigma \), responsible for emitting events.
- **\( q_0 \)**: The initial state.
- **\( F \)**: The set of accepting (final) states.

By convention, $\Sigma^*$ denotes the set of all finite sequences (strings) of events generated by $\Sigma$. A word $w = \sigma_1\sigma_2\ldots\sigma_n \in \Sigma^*\in\Sigma^*$ is an accepting word if, after processing the entire sequence, the system transitions into one of its accepting (final) states $F$.

This model conform to the actor model but differ from the Mealy machine in the following way:

1. Output word space $\Gamma$ is removed.
2. The running input word $\Sigma^*$ is composed of outside input word and input word that is generated from actions, both inputs conform with $\Sigma$.

This sextuple framework aligns with the Actor Model by facilitating **state encapsulation** and **event-driven message passing**. Unlike traditional automata where outputs are separate from inputs, here, the action function \( \lambda \) generates new events within \( \Sigma \), enabling **dynamic and asynchronous interactions** within the system.

### State space $Q$

The **state space** $Q=\{s_0,s_1,s_2,s_3\}$, where

- **\( s_0 = \text{Idle} \)**: The system is idle, waiting for a `FETCH_DATA` command to initiate data retrieval.
- **\( s_1 = \text{FetchingData} \)**: The system is actively fetching data from CryptoCompare upon receiving `FETCH_DATA`.
- **\( s_2 = \text{Publishing} \)**: Once data is ready (`DATA_READY`), the system publishes the aggregated data to Kafka/Redpanda.
- **\( s_3 = \text{Error} \)**: Handles any failures during fetching or publishing, responding to `FETCH_FAILURE` or `PUBLISH_FAILURE`.

The initial state $q_0=s_0$ and the acceptor $F={s_0}$:

- **Initial State (\( s_0 = \text{Idle} \))**: Awaiting commands to fetch or publish data. This is also the **accepting state**, indicating that operations have successfully cycled back to an idle state.

### The input space $\Sigma$

$\Sigma=\{\sigma_1,\sigma_2,\sigma_3,\sigma_4,\sigma_5,\sigma_6\}$, where

- $\sigma_1 = FETCH\_DATA$: signal to initiate the data fetching.
- $\sigma_2 = DATA\_READY$: notification that data has been successfully fetched.
- $\sigma_3 = FETCH\_FAILURE$: notification that data fetched failed.
- $\sigma_4 = PUBLISH\_SUCCESS$: confirmation that data has been successfully published.
- $\sigma_5 = PUBLISH\_FAILURE$: notification of a failure in publishing data.
- $\sigma_6 = RESET$: signal to reset the actor from an error state.

In our platform, the elements of $\Sigma$ are termed **events**, which can originate from external user inputs or be generated internally by the actor's actions.

### The transition function $\delta$

The transition function \( \delta \) defines state transitions based on incoming events. Each transition is triggered by an event, leading to a state change that may also result in generating new events through the action function \( \lambda \).

**Transition function** $\delta: Q\times\Sigma\rightarrow Q$ is defined as

  <div class="table">
    <div class="table-caption">
      <span class="table-number">Table 1:</span>
      Transition function $\delta$ for producer actor - a symbolic definition:
    </div>

| current state | event                | next state |
| ------------- | -------------------- | ---------- |
| $s_0$         | $\sigma\neq\sigma_1$ | $s_0$      |
| $s_0$         | $\sigma_1$           | $s_1$      |
| $s_1$         | $\sigma_2$           | $s_2$      |
| $s_1$         | $\sigma_3$           | $s_3$      |
| $s_2$         | $\sigma_4$           | $s_0$      |
| $s_2$         | $\sigma_5$           | $s_3$      |
| $s_3$         | $\sigma_6$           | $s_0$      |

  </div>

  <div class="table">
    <div class="table-caption">
      <span class="table-number">Table 2:</span>
      Transition function $\delta$ for producer actor - a descriptive definition:
    </div>

| current state | event             | next state   |
| ------------- | ----------------- | ------------ |
| Idle          | if not FETCH_DATA | Idle         |
| Idle          | FETCH_DATA        | FetchingData |
| FetchingData  | DATA_READY        | Publishing   |
| FetchingData  | FETCH_FAILURE     | Error        |
| Publishing    | PUBLISH_SUCCESS   | Idle         |
| Publishing    | PUBLISH_FAILURE   | Error        |
| Error         | RESET             | Idle         |

  </div>

### The action $\lambda$

The **next-output function** $\lambda: Q\times\Sigma\rightarrow\Sigma$: We use $\Lambda$ for the set of _next-output_ functions, and $\Lambda=\{\lambda_1,\lambda_2,\lambda_3,\lambda_4\}$, where

- **$\lambda_1 = \text{startFetch}$**: Initiates the data fetching process, leading to either a successful fetch ($\sigma_2$) or a failure ($\sigma_3$).
- **$\lambda_2 = \text{startPublish}$**: Initiates the data publishing process, resulting in either a successful publish ($\sigma_4$) or a failure ($\sigma_5$).
- **$\lambda_3 = \text{errorHandler}$**: Handles errors by emitting a reset event ($\sigma_6$) to revert the system to the Idle state.

<div class="table">
  <div class="table-caption">
    <span class="table-number">Table 3:</span>
      The next-output function $\lambda$ for producer actor - a symbolic definition:
  </div>

| current state | event      | $\lambda\in\Lambda$ | output                   |
| ------------- | ---------- | ------------------- | ------------------------ |
| $s_1$         | $\sigma_1$ | $\lambda_1$         | $\sigma_2$ or $\sigma_3$ |
| $s_2$         | $\sigma_2$ | $\lambda_2$         | $\sigma_4$ or $\sigma_5$ |
| $s_3$         | $\sigma_3$ | $\lambda_3$         | $\sigma_6$               |
| $s_3$         | $\sigma_5$ | $\lambda_3$         | $\sigma_6$               |

  </div>

<div class="table">
  <div class="table-caption">
    <span class="table-number">Table 4:</span>
      Descriptive Output Function \( \lambda \)
  </div>

| Current State | Input Event     | Action       | Output                            |
| ------------- | --------------- | ------------ | --------------------------------- |
| FetchingData  | FETCH_DATA      | startFetch   | DATA_READY / FETCH_FAILURE        |
| Publishing    | DATA_READY      | startPublish | PUBLISH_SUCCESS / PUBLISH_FAILURE |
| Error         | FETCH_FAILURE   | errorHandler | RESET                             |
| Error         | PUBLISH_FAILURE | errorHandler | RESET                             |

  </div>

## Diagram

```latex {cmd, latex_zoom=2}
\documentclass{standalone}
\usepackage[svgnames]{xcolor} % Enables a wide range of color names
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning,shapes}
\usepackage{amsmath,amssymb,amsfonts}

\begin{document}
\begin{tikzpicture}[>=stealth',
                    shorten > = 1pt,
                    node distance = 1cm and 2cm,
                    el/.style = {inner sep=2pt, align=left, sloped, color=black, font=\tiny},
                    every label/.append style = {font=\tiny},
                    every node/.append style ={font=\normalsize},
                    every state/.append style={fill=LightBlue},
                    every edge/.append style={color=orange},
                    state/.style=state with output,
                    square/.style={regular polygon, regular polygon sides=4, minimum size=6cm, outer sep=0pt}
                    ]
\tikzset{
  sigma_1/.style={node contents=FETCH\_DATA},
  sigma_2/.style={node contents=DATA\_READY},
  sigma_3/.style={node contents=FETCH\_FAILURE},
  sigma_4/.style={node contents=PUBLISH\_SUCCESS},
  sigma_5/.style={node contents=PUBLISH\_FAILURE},
  sigma_6/.style={node contents=RESET}
}

\node[square] (A) {};

\node[state,accepting,
      initial right] (q0) at (A.corner 1) {$s_0$};
\node[state]         (q1) at (A.corner 2) {$s_1$\nodepart{lower} action: $\lambda_1$};
\node[state]         (q2) at (A.corner 3) {$s_2$\nodepart{lower} action: $\lambda_2$};
\node[state]         (q3) at (A.corner 4) {$s_3$\nodepart{lower} action: $\lambda_3$};

\path[->]
    (q0) edge [loop above] node[el] {other}        (q0)
    (q0)  edge  node[el,above,sigma_1] {}          (q1)
    (q1)  edge  node[el,above,sigma_2] {}          (q2)
    (q1)  edge  node[el,above,pos=0.75,sigma_3] {} (q3)
    (q2)  edge  node[el,above,pos=0.75,sigma_4] {} (q0)
    (q2)  edge  node[el,above,sigma_5]  {}         (q3)
    (q3)  edge  node[el,above,sigma_6]  {}         (q0);
\end{tikzpicture}
\end{document}
```

## Simulation

The transition function $\delta$ is extended inductively into $\bar\delta: Q\times\Sigma^*\rightarrow Q$ to describe the machine's behavior when fed whole input words. For the empty string $\varepsilon$, $\bar\delta(q,\varepsilon)=q$ for all states $q$, and for strings $wa$ where $a$ is the last symbol and $w$ is the (possibly empty) rest of the string, $\bar\delta(q,wa)=\delta(\bar\delta(q,w),a)$. The output function $\lambda$ may be extended similarly into $\bar\lambda(q,w)$, which gives the complete output of the machine when run on word $w$ from state $q$.

This allows the following to be defined:

### Accepting word

A word $w=a_1a_2,\ldots a_n\in\Sigma^*$ is an accepting word for the automaton if $\bar\delta(q_0,w)\in F$, that is, if after consuming the whole string $w$ the machine is in an accept state.

### Recognized language

The language $L\subseteq\Sigma^*$ _recognized_ by a machine is the set of all the words that are accepted by the machine, $L=\{w\in\Sigma^*\mid\bar\delta(q_0,w)\in F\}$.

### Simulation 1: Successful Data Fetch and Publish

- **Input Sequence:** \( w = \sigma_1 \sigma_2 \sigma_4 \)
- **Step-by-Step Execution:**
  1. **Initial State:** \( s_0 \) (Idle)
  2. **Event \( \sigma_1 \) (FETCH_DATA):**
     - Transition: \( s_0 \rightarrow s_1 \)
     - Action: startFetch
     - Output: \( \sigma_2 \) (DATA_READY)
  3. **Event \( \sigma_2 \) (DATA_READY):**
     - Transition: \( s_1 \rightarrow s_2 \)
     - Action: completeFetch
     - Output: \( \sigma_4 \) (PUBLISH_SUCCESS)
  4. **Event \( \sigma_4 \) (PUBLISH_SUCCESS):**
     - Transition: \( s_2 \rightarrow s_0 \)
     - Action: completePublish
     - Output: Idle state confirmed
  - **Final State:** \( s_0 \) (Idle) is an accepting state.
  - **Result:** \( w \) is an accepting word.

### Simulation 2: Data Fetch Failure

- **Input Sequence:** \( w' = \sigma_1 \sigma_3 \sigma_6 \)
- **Step-by-Step Execution:**
  1. **Initial State:** \( s_0 \) (Idle)
  2. **Event \( \sigma_1 \) (FETCH_DATA):**
     - Transition: \( s_0 \rightarrow s_1 \)
     - Action: startFetch
     - Output: \( \sigma_2 \) (DATA_READY) or \( \sigma_3 \) (FETCH_FAILURE)
  3. **Event \( \sigma_3 \) (FETCH_FAILURE):**
     - Transition: \( s_1 \rightarrow s_3 \)
     - Action: handleFetchError
     - Output: \( \sigma_6 \) (RESET)
  4. **Event \( \sigma_6 \) (RESET):**
     - Transition: \( s_3 \rightarrow s_0 \)
     - Action: resetFromError
     - Output: \( \sigma_6 \) (RESET)
  - **Final State:** \( s_0 \) (Idle) is an accepting state.
  - **Result:** \( w' \) is an accepting word despite the failure, indicating a potential need to revisit acceptance criteria.
