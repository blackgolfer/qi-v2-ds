$\newcommand{\argmin}{\mathop{\mathrm{argmin}}\limits}$
$\newcommand{\argmax}{\mathop{\mathrm{argmax}}\limits}$
$\newcommand{\A}{\mathfrak{A}}$
$\newcommand{\C}{\mathfrak{C}}$
$\newcommand{\D}{\mathfrak{D}}$
$\newcommand{\DS}{\mathfrak{S}}$
$\newcommand{\M}{\mathfrak{M}}$
$\newcommand{\N}{\mathbb{N}}$
$\newcommand{\Op}{\mathfrak{O}}$
$\newcommand{\op}{\mathfrak{o}}$
$\newcommand{\DP}{\mathfrak{P}}$
$\newcommand{\Q}{\mathbb{Q}}$
$\newcommand{\R}{\mathbb{R}}$

# A Multi Time-scale Finite State Machine Application Framework

## Abstract

This framework facilitates the efficient processing and visualization of high-volume financial data streams using Multi Time-scale Finite State Machines (MTSFSM). It is tailored to handle approximately 4,000 concurrent data streams, enabling complex computations and seamless integration with visualization platforms like TradingView. The framework ensures scalability, real-time responsiveness, and modularity, making it suitable for large-scale portfolio analysis and trading applications.

## 1. Data Source

### 1.1 Raw Data Source

Consider a raw source $S$ comprising multiple data streams. Each stream contains elements of the same type, denoted by $\D$.

Formally, define the raw source as:

$$
S = \{s_1, s_2, \ldots, s_n\}
$$

where:

- $s_i$ represents the $i^{th}$ th stream in the raw source $S$.
- $d_{ij}$ denotes the $j^{th}$ element within the $i^{th}$ stream $s_i$, such that $d_{ij}\in\D$, where $\D$ represents a standardized data structure for financial metrics (e.g., kbar data points).

The total number of streams $n$ is approximately 4,000.

### 1.2 Multi Time-scale Finite State Machine (MTSFSM) Operator

A **MTSFSM operator** maps each raw data stream $s_i$ in $S$ to a set of processed outputs $M$, incorporating multiple time scales. Specifically, define an operator $C$ with the following properties:

1. **Associativity with Respect to $S$:**
   $$
   C(S) = C(\{s_1, s_2, \ldots, s_n\}) = \{C(s_1), C(s_2), \ldots, C(s_n)\}
   $$
2. **Chainability:**

   For each $s\in S$,

   $$
   C(s) = \left[
   \begin{matrix}
   C_1(s) \\
   C_2(s) \\
   \vdots \\
   C_\eta(s)
   \end{matrix}
   \right]
   $$

   where each $C_i$ is a composition of sub-operators:

   $$
   C_i = c_i \circ c_{i-1} \circ \dots \circ c_1
   $$

   Here, $c_i$ is an operator that takes the output of $c_{i-1}$ as input, for $i = 2, \ldots, \eta$. Notice that $c_1$ is also an MTSFSM operator.

3. **Consistent Output Structure:**

   Each operator $c_i$ partitions the stream $s_i$ along the time domain and produces additional attributes. Formally, let:

   $$
   \DP(a) = \{[t_i, t_{i+1}], a\mid i = 0, 1, 2, \ldots, \xi, \, \xi\in\N, a\in\A\}
   $$

   be the time axis partition, where $\A$ is the attribute space. If the partition element $t_i$ is from stream $s_i$, we denote the partition as $\DP_s$. Let $a_i$ represent the attribute for $C_i$. Then, each operator $C_i$ is defined as:

   $$
   C_i: s_i \mapsto \DP_s(a_i), \quad \forall s_i \in S.
   $$

   In this notation, since MTSFSM operator maps $S$ to $M$, so we have $M=\{m_1, m_2, \ldots, m_n\}$, where
   $$m_i=\{C_1(s_i),C_2(s_i),\ldots,C_\eta(s_i)\}=\{\DP_{s_i}(a_1), \DP_{s_i}(a_2), \ldots, \DP_{s_i}(a_\eta)\}.$$

## 2. The Data Set

The **data set** $K$ in the system is the combination of both the raw data streams and their processed outputs. Formally,

$$
K = \{ k_1, k_2, \ldots, k_n \}
$$

where each $k_i$ is defined as:

$$
k_i = \langle s_i, \{m_1, m_2, \ldots, m_\eta \} \rangle
$$

Or equivalently,
$$k_i=\{s_i, \{\DP_{s_1}(a_1), \DP_{s_2}(a_2), \ldots, \DP_{s_n}(a_\eta)\}\}$$
This structure allows each data stream to be individually processed and stored alongside its corresponding multi-scale analyses, enabling efficient querying and visualization.

## 3. ty-mm: a concrete MTSFSM operator

In this section, you introduce the **ty-mm**, a specific implementation of the MTSFSM operator tailored for financial market analysis.

### Overview

- **Number of Sub-Operators:** \( \eta = 6 \)
- **Associativity:** The operator is associative, ensuring that the processing of one stream doesn't interfere with others.

Because of the associativity of the operator, in what follows we focus on one stream for $s\in S$, and use $d_i\in\D$ for data item in $s$,
that is $s=\{d_0,d_1,\ldots,\}$. As for the data type, $\D=\{t,(o,h,l,c,v)\in\Q\times\R_+^5\}$, here we use $\R_+$ to represent the space of non negative double, and $\Q$ the non-negative integer. Furthermore, for data $t$, $o$, $h$, $l$, $c$ and $v$ in $d\in s$, we use function notation $d('time')$, $d('open')$, $d('high')$, $d('low')$, $d('close')$ and $d('volume')$ respectively. A data point $d\in s$ is called a kbar, and a stream $s$ is called a kline.

### 3.1 $c_1$: Merging operator

#### On the relationship between two klines

Let's consider two kbars in the kline $s$, $d_1$ and $d_2$, we want to identify all the possible relationships in which kbar information (open, high, low, close and volume) is limited to just (high, low):

1. $d_1>d_2$ if $((d_1('high')>d_2('high'))\ and\ (d_1('low')\geq d_2('low')))$ or $((d_1('high')\geq d_2('high'))\ and\ (d_1('low')>d_2('low')))$
2. $d_1<d_2$ if $((d_1('high)<d_2('high))\ and\ (d_1('low')\leq d_2('low')))$ or $((d_1('high)\leq d_2('high))\ and\ (d_1('low')<d_2('low')))$
3. $d_1\subset d_2$ if $((d_2('high')>d_1('high'))\ and\ (d_2('low')\leq d_1('low')))$ or $((d_2('high')\geq d_1('high'))\ and\ (d_2('low')< d_1('low')))$
4. $d_2\subset d_1$ if $((d_1('high')>d_2('high'))\ and\ (d_1('low')\leq d_2('low')))$ or $((d_1('high')\geq d_2('high'))\ and\ (d_1('low')< d_2('low')))$
5. $d_1=d_2$ if $(d_1('high')=d_2('high'))\ and\ (d_1('low')=d_2('low'))$

We use data type $Rel=\{1,2,3,4,5\}$ to represent this relationship and function $rel$ to check the relationship of a pair of klines, that is
$$ ref: (d_1,d_2)\mapsto Rel$$
and

$$
ref(d_1,d_2)=
\begin{cases}
1 & for\ d_1>d_2, \\
2 & for\ d_1<d_2, \\
3 & for\ d_1\subset d_2,\\
4 & for\ d_2\subset d_1, \\
5 & for\ d_1=d2
\end{cases}
$$

#### The up and down pivots

A pivot is one of two particular patterns of three adjacent kbars. Let $d_1$, $d_2$ and $d_3$ be three adjacent kbars, they sastisfies:
$$d_1('time')<d_2('time')<d_3('time').$$
We define the pivot function as

$$
pivot(d_1,d_2,d_3)=
\begin{cases}
2 & if\ (d_1('high')<d_2('high'))\ and\ (d_3('high')<d_2('high')) \\
1 & if\ (d_1('high')<d_2('high'))\ and\ (d_2('high')<d_3('high')) \\
-1 & if\ (d_1('low')>d_2('low'))\ and\ (d_2('low')>d_3('low')) \\
-2 & if\ (d_1('low')>d_2('low'))\ and\ (d_3('low')>d_2('low')) \\
0 & otherwise
\end{cases}
$$

when $pivot(d_1,d_2,d_3) = 2$, we say $(d_1,d_2,d_3)$ is an _up pivot_, likewise, $(d_1,d_2,d_3)$ is called a _down pivot_ if $pivot(d_1,d_2,d_3)=-2$.

It is not hard to see the meaning of pivot is valid only if for any adjacent kbars $d_1$ and $d_2$ in the kline $s$, $rel(d_1,d_2)\in\{1,2\}$. In this case, $pivote(d_1,d_2,d_3)\neq 0$ for any adjacent $d_1$, $d_2$ and $d_3$. In other words, there are only four patterns for adjacent $d_1,d_2,d_3$, two turning patterns: top pivot (2) and down pivot (-2); and two trend patterns: up-trend (1) and down-trend (-1). We call kline with such property a normalized kline.

### The purpose of operator $c_1$

The purpose of operator $c_1$ is to partition kline $s$ into type 1 and type 0 segments. The result can be used to construct a normalized kline, so that any adjacent $d_1,d_2,d_3$ can only have four possible patterns, top pivot, down pivot, up-trend and down-trend.

### Definition of $c_1$ and its outputs

The merging operator $c_1$ is defined as $c_1: s\mapsto \{[t_i,t_{i+1}],a_{1i}\}$, where $a_{1i}=\{\tau_i\in\{0,1\}, (t_i^l,l),(t_i^h,h)\},\forall s\in S$ and

- $\tau_i$ is segment type for segment [a,b], defined as:
  $$
  \tau_i =
  \begin{cases}
  1, & ref(d_1,d_2)\in\{1,2\}, \forall adjacent\ kbars\ d_1('time')\in[a,b],d_2('time')\in[a,b] \\
  0, & \text{otherwise}
  \end{cases}
  $$
- $(t_i^l, l)$ represents the lowest point in segment $[t_i, t_{i+1}]$:
  $$
  l = \min_j \{ d_j('low') \mid d_j('time') \in [t_i, t_{i+1}] \}
  $$
  and
  $$
  t_i^l = \argmin_{d_j('time') \in [t_i, t_{i+1}]} \{ d_j('low') \}
  $$
- \( (t*i^h, h) \) represents the highest point in segment \( [t_i, t*{i+1}] \):
  $$
  h = \max_j \{ d_j('high') \mid d_j('time') \in [t_i, t_{i+1}] \}
  $$
  and
  $$
  t_i^h = \argmax_{d_j('time') \in [t_i, t_{i+1}]} \{ d_j('high') \}
  $$

#### Algorithm

The implementation of $c_1$ operator uses $FSM$ defined below.

#### State machine

Let $d'$ be the last kbar and $d$ be the current kbar. The finite state machine $FSM = (Q, \Sigma, \delta, q_0, F, \Lambda)$ for $c_1$ operator is defined as:

1. State space $Q=\{'lastbar','seg_type_0','seg_type_1','processing'\}$, where
   - 'seg_type_0': $rel(d',d)\notin\{1,2\}$
   - 'seg_type_1': $rel(d',d)\in\{1,2\}$
2. Input symbols $\Sigma=\{'START','FINISH','PROCESSING'\}$.
3. State transition function $\delta: Q\times\Sigma\rightarrow Q\times\Lambda$,
   - $\delta('seg_type_0','START')
4. Initial state $q_0=1$:
5. Final states $F=\{-1\}$
6. Action space $\Lambda$: $\Lambda = \Lambda_{exit}\times\Lambda_{entry}$, where $\Lambda_{exit(q;d',d)}=\{exit(q;d',d)\}$, $\Lambda_{entry}=\{entry(q;d',d)\}$, both contains only one function with one primary input argument $q\in Q$ and two attributes $d',d\in\D$. The $exit$ and $entry$ functions will be specified in the psuedo code section.

##### Pseudo code for function rel

```
PROGRAM rel:
  READ d1,d2;
  IF ((d1.high>d2.high && d1.low>=d2.low) || (d1.high>=d2.high && d1.low>d2.low))
   THEN return 1;
  ELSE IF ((d2.high>d1.high && d2.low>=d1.low) || (d2.high>=d1.high && d2.low>d1.low))
   THEN return 2;
  ELSE IF ((d2.high>d1.high) && d2.low<=d1.low) || ((d2.high>=d1.high) && d2.low<d1.low)
   THEN return 3;
  ELSE IF ((d1.high>d2.high) && d1.low<=d2.low) || ((d1.high>=d2.high) && d1.low<d2.low)
   THEN return 4;
  ELSE IF ((d1.high==d2.high) && (d1.low==d2.low))
   THEN return 5;
  ENDIF;
END.
```

```
PROGRAM entry:
  READ q,d;
  IF (q==0)
   THEN
      set T=0; // T is $\tao$ in the output description
      create a variable seg with a pair (a,b) for segment, and set seg.a=d.('time'), seg.b=undefined
      return rel(d',d)
  ELSE if (q==1)
   THEN
      set T=1;
      create a variable seg with a pair (a,b) for segment, and set seg.a=d.('time'), seg.b=undefined
      return rel(d',d)
  ELSE // q=-1
      return rel(d',d)
```

### 3.2 $c_2$: bline operator

### 3.3 $c_3$: brange operator

### 3.4 $c_4$: dline operator

### 3.5 $c_5$: drange

### 3.6 $c_6$: trend operator

## 4. Applications

An **application** $A$ is a function mapping the data set $K$ to a specific output. Formally,

$$
A: K \rightarrow \Op
$$

where $\Op$ represents the output space.

### 3.1. Associative Applications

An application $A$ is termed **associative** if it operates independently on each element of $K$:

$$
A(K) = A(\{ k_1, k_2, \ldots, k_n \}) = \{ A(k_1), A(k_2), \ldots, A(k_n) \}
$$

**Implications:**

- **Parallel Processing:** Facilitates concurrent processing of each data stream, enhancing scalability and efficiency.
- **Modularity:** Promotes modularity, allowing individual components to be updated or scaled without impacting others.

## 4. TradingView Charting Library Application

The **TradingView** application serves as the visualization layer within this framework. It is associative, meaning it independently maps each element of the data set $K$ to its visual representation on the screen.

### 4.1. Associativity in Visualization

Given the associative properties of both $K$ and $A$, TradingView can render each data stream's raw and processed data independently. This ensures that the visualization remains responsive and scalable, even with a high volume of data streams.

### 4.2. Data Integration with TradingView

**Workflow:**

1. **Data Consumption:**

   - **Real-Time Data:** Subscribe to Redpanda topics (`kline-data`, `ty-mm-data`) to receive live updates.
   - **Historical Data:** Query QuestDB to retrieve historical $D$ data for initial chart rendering.

2. **Data Mapping:**

   - **Raw Data ($s_i$):** Represented as K-Line (Candlestick) charts.
   - **Processed Data ($m_i=\{C_1(s_i),C_2(s_i),\ldots,C_\eta(s_i)\}$):** Overlaid as QI market model indicators (bline, brange, dline, drange, trend).

3. **Visualization:**
   - Utilize TradingView’s APIs to dynamically update charts as new data arrives, ensuring real-time responsiveness.

**Example Visualization Flow:**

- **Initial Load:**
  - Fetch and render historical kline data and ty-mm data from QuestDB.
- **Real-Time Updates:**
  - Upon receiving new $d_{ij}$ elements from Redpanda, update the corresponding chart streams and overlay new QI market model indicators.

<img src='https://g.gravizo.com/svg?
digraph finite_state_machine {
   rankdir=LR;
   node [shape = circle; height="1"; style=filled; color=AntiqueWhite];
   up [shape = doublecircle; height="1"; style=filled; color=red];
   down [shape = doublecircle; height="1"; style=filled; color=green];
   init [shape = doublecircle; height="1"; style=filled; color=antiquewhite; label="init"];
   end [ shapte = doublecircle; height="1"; style=filled; color=grey; label="end"];
   edge [color = grey; fontsize=10];
   init -> up [ label = "state=1"];
   init -> down [ label = "state=0"];
   up -> down [ label = "state=0" ];
   up -> end [ label = "finishing last bar" ];
   down -> up [ label = "state=1" ];
   down -> end [ label = "finishing last bar" ];
}
'/>
